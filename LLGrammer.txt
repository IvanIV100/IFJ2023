<Prog> -> e
<Prog> -> <stmntList> <prog>
<Prog> -> <funcDef> <prog> // global scope
<Prog> -> EOF
<stmntList> -> e
<stmntList> -> <stmnt> <stmntList> 
<stmnt> -> <varDef>
<stmnt> -> id <FuncCallOps>
<stmnt> -> <Condition>
<stmnt> -> <Loop>
<stmnt> -> <Return> only in funcDef bool
<paramListFirst> -> e
<paramListFirst> -> <param> <paramList>
<paramList> -> e
<paramList> -> , <param> <paramList>
<param> -> id id : <Type>
<param> -> _ id : <Type>
<varDef> -> let/var id <varDefOptional>  
<varDefOptional> -> e
<varDefOptional> -> : <type> <varDefAss>
<varDefOptional> -> <varDefAss> //check if in func
<varDefAss> -> e
<varDefAss> -> = <AssignOps>
<funcDef> -> func id ( <paramListFirst> ) <funcRetType> { <stmntList> <return> }
<funcRetType> -> -> <type>
<funcRetType> -> e
<FuncCallOps> ->   = <AssignOps>
<FuncCallOps> -> ( <InParamListFirst> )
<AssignOps> ->  <expr>
<AssignOps> ->  id ( <InParamListFirst> )
<Condition> -> if <condOps> { <stmntList> } else { <stmntList> }
<condOps> -> <expr>
<condOps> -> let id
<Loop> -> for id in <range> { <loopExe> } //check if supported format for or extension
<range> -> //fin after check
<Loop> -> while <expr> { <loopExe> }
<loopExe> -> <stmnt> <loopExe> //check if not missing (break/cont)
<loopExe> -> e
<InParamListFirst> -> e
<InParamListFirst> -> <inParam> <InParamList>
<InParamList> -> , <InParam> <InParamList>
<InParamList> -> e
<InParam> -> id <opID>
//<InParam> -> <expr> // can be expre?
<opID> -> : id
<return> -> <expr>
<expre> -> give away to handle 
